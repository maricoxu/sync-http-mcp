# Sync-HTTP-MCP 设计文档 (基于Git增量同步版)

## 1. 项目概述

### 1.1 背景

百度内部开发环境需要通过relay-cli跳板机连接，传统SSH连接方式无法直接与内部服务器建立持久可靠的连接。开发人员需要一种可靠且高效的方式在本地IDE（如Cursor）中编辑代码，并在远程服务器上进行同步、编译、测试等操作。

现有的块级增量同步方案虽然有所改进，但在某些场景下可能存在性能瓶颈和同步一致性问题。本次设计引入Git的差异对比和补丁机制，实现更高效、可靠的增量同步方案。

### 1.2 设计目标

1. **高效同步**：仅传输实际变更的内容，极大减少网络传输量
2. **一致性保障**：利用Git的补丁机制，确保同步前后代码的一致性
3. **版本可追溯**：每次同步可以作为一次提交，方便追踪变更历史
4. **冲突处理**：内置冲突检测和解决机制，处理远程和本地同时修改的情况
5. **简单可靠**：依托Git成熟的差异对比和补丁功能，降低自研复杂度

### 1.3 核心价值

- 显著提高同步效率，尤其对大型代码库的小范围修改极为高效
- 提供更强的数据一致性保障和变更历史跟踪能力
- 减少带宽消耗，适合网络条件不稳定的远程开发场景
- 自动化冲突处理流程，减少人工干预需求

## 2. 系统架构

### 2.1 整体架构

系统依然由两个主要部分组成，但增量同步机制由原来的自定义块对比改为基于Git的patch机制：

1. **本地客户端（Local Client）**
   - 集成到Cursor IDE或独立命令行工具
   - 通过Git生成变更补丁（patch）
   - 发送patch到远程服务器
   - 处理同步结果和可能的冲突

2. **内网HTTP服务器（Remote HTTP Server）**
   - 部署在百度内网服务器上
   - 接收并应用Git patch
   - 处理可能的冲突并返回结果
   - 执行编译和测试命令

### 2.2 架构图

```
┌─────────────────┐       端口转发隧道       ┌────────────────────┐
│                 │                         │                    │
│  Local Client   │◄───────HTTP/WS─────────►│  Remote HTTP Server │
│ (生成Git Patch)  │                         │  (应用Git Patch)    │
│                 │                         │                    │
└─────────────────┘                         └────────────────────┘
        │                                            │
        ▼                                            ▼
┌─────────────────┐                       ┌────────────────────┐
│  本地Git仓库     │                       │   远程Git仓库       │
└─────────────────┘                       └────────────────────┘
```

### 2.3 增量同步流程

```
┌──────────┐     ┌──────────┐     ┌──────────┐     ┌──────────┐
│ 本地修改  │────►│生成Git Diff│────►│传输Patch │────►│ 应用Patch │
└──────────┘     └──────────┘     └──────────┘     └──────────┘
                                                       │
                                                       ▼
┌──────────┐     ┌──────────┐     ┌──────────┐     ┌──────────┐
│ 同步完成  │◄────│ 处理结果  │◄────│冲突检测  │◄────│更新远程仓库│
└──────────┘     └──────────┘     └──────────┘     └──────────┘
```

## 3. 技术实现

### 3.1 同步机制详解

#### 3.1.1 基于Git的差异生成与应用

1. **本地差异生成**：
   - 使用`git diff`生成当前工作区与上次同步状态的差异
   - 使用`git format-patch`创建可应用的补丁文件
   - 支持`--binary`选项处理二进制文件变更

2. **远程补丁应用**：
   - 使用`git apply`应用补丁到远程仓库
   - 支持`--check`预检查补丁是否可以干净应用
   - 支持`--reject`选项处理部分应用和冲突情况

3. **同步基准点**：
   - 每次成功同步创建一个"同步点"commit
   - 后续差异基于最近的同步点生成
   - 保证增量同步的连续性和一致性

#### 3.1.2 冲突处理策略

1. **预检测**：
   - 同步前检查本地和远程是否有冲突变更
   - 计算本地和远程的最后同步点，确保基准一致

2. **冲突解决**：
   - 自动合并算法优先处理无冲突变更
   - 对有冲突的文件，生成冲突标记并通知用户
   - 提供冲突解决界面，用户选择保留哪个版本或手动合并

3. **回滚机制**：
   - 同步失败时能回滚到上一个稳定状态
   - 保留冲突信息供后续解决

### 3.2 API设计

#### 3.2.1 Git补丁同步

```
POST /api/v1/sync/patch
Request:
{
  "base_commit": "同步基准点commit hash",
  "patch_content": "base64编码的patch内容",
  "binary_files": [
    {
      "path": "binary_file.bin",
      "content": "base64编码内容"
    }
  ]
}

Response:
{
  "status": "success|conflict|error",
  "new_commit": "新同步点commit hash",
  "applied_files": ["file1.txt", "file2.cpp"],
  "conflicts": [
    {
      "path": "conflict_file.txt",
      "conflict_content": "base64编码的冲突内容"
    }
  ],
  "message": "详细状态信息"
}
```

#### 3.2.2 同步点管理

```
GET /api/v1/sync/status
Response:
{
  "last_sync_commit": "最后同步点commit hash",
  "last_sync_time": "2023-05-20T15:30:45Z",
  "pending_changes": true|false,
  "repository_status": "clean|dirty"
}
```

#### 3.2.3 冲突解决

```
POST /api/v1/sync/resolve
Request:
{
  "conflicts": [
    {
      "path": "conflict_file.txt",
      "resolution": "local|remote|merged",
      "merged_content": "base64编码的合并后内容" // 如果resolution为merged
    }
  ]
}

Response:
{
  "status": "success|error",
  "new_commit": "冲突解决后的commit hash",
  "message": "冲突解决结果"
}
```

## 4. 客户端实现

### 4.1 Git操作封装

客户端需要封装以下Git操作：

1. **初始化**：
   ```python
   def init_repo(path: str, remote_url: str = None):
       # 初始化本地Git仓库
       # 可选：设置远程同步服务器
   ```

2. **差异生成**：
   ```python
   def generate_patch(base_commit: str = None):
       # 基于某个commit或默认的HEAD生成patch
       # 处理二进制文件的特殊情况
   ```

3. **同步状态检查**：
   ```python
   def check_sync_status():
       # 检查本地和远程的同步状态
       # 返回最后同步点和变更统计
   ```

4. **应用远程更改**：
   ```python
   def apply_remote_changes(remote_patch):
       # 应用从远程获取的更改到本地
       # 处理可能的冲突
   ```

### 4.2 同步命令接口

客户端命令行接口示例：

```bash
# 初始化同步环境
python client.py init --workspace ./project --remote http://server:8081

# 执行同步操作
python client.py sync --mode git-patch

# 查看同步状态
python client.py status

# 解决冲突
python client.py resolve --strategy [local|remote|interactive]
```

## 5. 服务器端实现

### 5.1 Git仓库管理

服务器端需要实现以下Git仓库管理功能：

1. **仓库初始化**：
   ```python
   async def init_repo(path: str):
       # 在指定路径初始化Git仓库
       # 配置适当的权限和提交用户信息
   ```

2. **应用补丁**：
   ```python
   async def apply_patch(patch_content: str, base_commit: str):
       # 尝试应用补丁
       # 识别和处理冲突
   ```

3. **创建同步点**：
   ```python
   async def create_sync_point(message: str = "Sync point"):
       # 创建一个标记同步状态的commit
       # 返回新的commit hash
   ```

### 5.2 API端点实现

服务器需要实现以下API端点：

1. **接收并应用补丁**：
   - 处理`POST /api/v1/sync/patch`请求
   - 验证patch有效性和基准点一致性
   - 尝试应用patch并处理结果

2. **同步状态查询**：
   - 处理`GET /api/v1/sync/status`请求
   - 返回当前仓库状态和最后同步点

3. **冲突解决**：
   - 处理`POST /api/v1/sync/resolve`请求
   - 根据用户选择解决冲突并创建新的同步点

## 6. 性能与可靠性

### 6.1 性能优化

1. **差异压缩**：
   - 应用gzip压缩patch内容，减少传输大小
   - 对大型二进制文件可考虑增量二进制diff算法

2. **批处理机制**：
   - 积累多个小改动后批量生成patch
   - 设置合理的自动同步间隔，避免频繁通信

3. **缓存策略**：
   - 缓存近期同步点信息，加速差异生成
   - 维护文件状态缓存，优化差异检测

### 6.2 可靠性保障

1. **同步验证**：
   - 同步后通过哈希比对验证内容一致性
   - 支持完整性校验，确保patch正确应用

2. **失败恢复**：
   - 同步操作事务化，确保原子性
   - 保存同步前状态，支持回滚操作

3. **断点续传**：
   - 大型patch支持分块传输和断点续传
   - 网络中断后能从断点处恢复

## 7. 使用场景

### 7.1 日常开发场景

1. **增量代码同步**：
   - 本地修改少量文件后一键同步到远程服务器
   - 快速应用远程服务器上的更改到本地

2. **远程编译测试**：
   - 同步完成后自动触发远程编译
   - 实时获取编译和测试结果

### 7.2 多人协作场景

1. **代码同步与合并**：
   - 多人同时修改远程代码库，自动处理合并
   - 变更历史清晰可追踪，支持代码审核

2. **分支管理**：
   - 支持多分支开发，不同开发者同步到不同分支
   - 提供分支合并和冲突解决机制

## 8. 未来扩展

1. **完整Git功能支持**：
   - 支持分支创建、切换、合并等完整Git操作
   - 与GitHub/GitLab集成，支持PR/MR流程

2. **智能冲突解决**：
   - 利用AI辅助自动解决某些类型的冲突
   - 提供更友好的冲突解决界面

3. **分布式协作增强**：
   - 多地协作的延迟优化和冲突预防
   - 团队协作工作流定制与集成

4. **CI/CD集成**：
   - 同步后自动触发CI/CD流程
   - 测试结果实时反馈到本地IDE 